#because we need the barro data set
library(quantreg)
data(barro)
y <- barro$y.net
x <- as.matrix(barro[,-1])
qbr <- rq.pen(x,y,alg="br")
qfn <- rq.pen(x,y,alg="fn")
qhuber <- rq.pen(x,y,alg="huber")
rqe <- rq.pen(x,y,tau=.25,penalty="ENet",a=seq(0,1,.1),alg="huber")
aicm <- qic.select(rqe, method="AIC")
#BIC is the default method
bicm <- qic.select(rqe)
#following returns the coefficients of the selected model
coefficients(bicm)
#provides information about the selected model
bicm$modelsInfo
#provides IC values for all possible models
bicm$ic[1:5,1:5]
#lasso model for 9 quantiles
tvals <- seq(.1,.9,.1)
rqmt <- rq.pen(x,y,tau=tvals)
#default is to find the optimal value of
# lambda for each quantile separately
rqmt_st <- qic.select(rqmt)
# alternative option is to find one value of
# lambda best for all tau. Below code
# also provides different weights for the models
rqmt_g <- qic.select(rqmt,septau = FALSE,weights=sqrt(tvals*(1-tvals)))
# first one will have different values of lambda for each quantile
# second approach will provide the same value for lambda for all quantiles
rqmt_st$modelsInfo
rqmt_g$modelsInfo
#below command gets coefficients for the selected model optimized for each quantile
coefficients(rqmt_st)
#code is the same for a group penalty
# This is not a great use of a group penalty and only for
# example
g <- c(rep(1,4),rep(2,3),rep(3,3),rep(4,3))
rqgroup <- rq.group.pen(x,y,groups=g,tau=seq(.1,.9,1))
rqgroup_ic <- qic.select(rqgroup)
quants <- seq(.1,.9,.1)
r1 <- rq.pen(x,y,a=seq(0,1,.1),tau=quants,penalty="ENet",alg="huber")
#Below plots the coefficient values for .1 quantile with a=.1
plot(r1,tau=.1,a=.1)
#Below code would provide plots for all possible values of a and tau
#plot(r1)
rm(list=ls(all=TRUE))
library(devtools)
devtools::unload("rqPen")
install_github("bssherwood/rqpen")
rm(list=ls(all=TRUE))
library(devtools)
devtools::unload("rqPen")
install_github("bssherwood/rqpen")
# Chunk 1: preliminaries
options(prompt = "R> ", continue = "+  ", width = 70, useFancyQuotes = FALSE)
library("MASS")
# Chunk 2
library(rqPen)
#quantreg is required for rqPen, but call directly here
#because we need the barro data set
library(quantreg)
data(barro)
y <- barro$y.net
x <- as.matrix(barro[,-1])
qbr <- rq.pen(x,y,alg="br")
qfn <- rq.pen(x,y,alg="fn")
# Chunk 3
qhuber <- rq.pen(x,y,alg="huber")
# Chunk 4
rqe <- rq.pen(x,y,tau=.25,penalty="ENet",a=seq(0,1,.1),alg="huber")
aicm <- qic.select(rqe, method="AIC")
#BIC is the default method
bicm <- qic.select(rqe)
#following returns the coefficients of the selected model
coefficients(bicm)
#provides information about the selected model
bicm$modelsInfo
#provides IC values for all possible models
bicm$ic[1:5,1:5]
# Chunk 5
#lasso model for 9 quantiles
tvals <- seq(.1,.9,.1)
rqmt <- rq.pen(x,y,tau=tvals)
#default is to find the optimal value of
# lambda for each quantile separately
rqmt_st <- qic.select(rqmt)
# alternative option is to find one value of
# lambda best for all tau. Below code
# also provides different weights for the models
rqmt_g <- qic.select(rqmt,septau = FALSE,weights=sqrt(tvals*(1-tvals)))
# first one will have different values of lambda for each quantile
# second approach will provide the same value for lambda for all quantiles
rqmt_st$modelsInfo
rqmt_g$modelsInfo
#below command gets coefficients for the selected model optimized for each quantile
coefficients(rqmt_st)
#code is the same for a group penalty
# This is not a great use of a group penalty and only for
# example
g <- c(rep(1,4),rep(2,3),rep(3,3),rep(4,3))
rqgroup <- rq.group.pen(x,y,groups=g,tau=seq(.1,.9,.1))
rqgroup_ic <- qic.select(rqgroup)
quants <- .3#seq(.1,.9,.1)
r1 <- rq.pen(x,y,a=c(0,1),tau=quants,penalty="ENet",alg="huber")
#Below plots the coefficient values for .1 quantile with a=.1
plot(r1,tau=.1)
#Below code would provide plots for all possible values of a and tau
#plot(r1)
plot(r1)
r1$lambda
plot(r1)
R1
r1
plot(r1,logLambda=TRUE)
# Chunk 1: preliminaries
options(prompt = "R> ", continue = "+  ", width = 70, useFancyQuotes = FALSE)
library("MASS")
# Chunk 2
library(rqPen)
#quantreg is required for rqPen, but call directly here
#because we need the barro data set
library(quantreg)
data(barro)
y <- barro$y.net
x <- as.matrix(barro[,-1])
qbr <- rq.pen(x,y,alg="br")
qfn <- rq.pen(x,y,alg="fn")
# Chunk 3
qhuber <- rq.pen(x,y,alg="huber")
# Chunk 4
rqe <- rq.pen(x,y,tau=.25,penalty="ENet",a=seq(0,1,.1),alg="huber")
aicm <- qic.select(rqe, method="AIC")
#BIC is the default method
bicm <- qic.select(rqe)
#following returns the coefficients of the selected model
coefficients(bicm)
#provides information about the selected model
bicm$modelsInfo
#provides IC values for all possible models
bicm$ic[1:5,1:5]
# Chunk 5
#lasso model for 9 quantiles
tvals <- seq(.1,.9,.1)
rqmt <- rq.pen(x,y,tau=tvals)
#default is to find the optimal value of
# lambda for each quantile separately
rqmt_st <- qic.select(rqmt)
# alternative option is to find one value of
# lambda best for all tau. Below code
# also provides different weights for the models
rqmt_g <- qic.select(rqmt,septau = FALSE,weights=sqrt(tvals*(1-tvals)))
# first one will have different values of lambda for each quantile
# second approach will provide the same value for lambda for all quantiles
rqmt_st$modelsInfo
rqmt_g$modelsInfo
#below command gets coefficients for the selected model optimized for each quantile
coefficients(rqmt_st)
#code is the same for a group penalty
# This is not a great use of a group penalty and only for
# example
g <- c(rep(1,4),rep(2,3),rep(3,3),rep(4,3))
rqgroup <- rq.group.pen(x,y,groups=g,tau=seq(.1,.9,.1))
rqgroup_ic <- qic.select(rqgroup)
# Chunk 1: preliminaries
options(prompt = "R> ", continue = "+  ", width = 70, useFancyQuotes = FALSE)
library("MASS")
# Chunk 2
library(rqPen)
#quantreg is required for rqPen, but call directly here
#because we need the barro data set
library(quantreg)
data(barro)
y <- barro$y.net
x <- as.matrix(barro[,-1])
qbr <- rq.pen(x,y,alg="br")
qfn <- rq.pen(x,y,alg="fn")
# Chunk 3
qhuber <- rq.pen(x,y,alg="huber")
# Chunk 4
rqe <- rq.pen(x,y,tau=.25,penalty="ENet",a=seq(0,1,.1),alg="huber")
aicm <- qic.select(rqe, method="AIC")
#BIC is the default method
bicm <- qic.select(rqe)
#following returns the coefficients of the selected model
coefficients(bicm)
#provides information about the selected model
bicm$modelsInfo
#provides IC values for all possible models
bicm$ic[1:5,1:5]
# Chunk 5
#lasso model for 9 quantiles
tvals <- seq(.1,.9,.1)
rqmt <- rq.pen(x,y,tau=tvals)
#default is to find the optimal value of
# lambda for each quantile separately
rqmt_st <- qic.select(rqmt)
# alternative option is to find one value of
# lambda best for all tau. Below code
# also provides different weights for the models
rqmt_g <- qic.select(rqmt,septau = FALSE,weights=sqrt(tvals*(1-tvals)))
# first one will have different values of lambda for each quantile
# second approach will provide the same value for lambda for all quantiles
rqmt_st$modelsInfo
rqmt_g$modelsInfo
#below command gets coefficients for the selected model optimized for each quantile
coefficients(rqmt_st)
#code is the same for a group penalty
# This is not a great use of a group penalty and only for
# example
g <- c(rep(1,4),rep(2,3),rep(3,3),rep(4,3))
rqgroup <- rq.group.pen(x,y,groups=g,tau=seq(.1,.9,.1))
rqgroup_ic <- qic.select(rqgroup)
quants <- seq(.1,.9,.1)
r1 <- rq.pen(x,y,a=seq(0,1,.1),tau=quants,penalty="ENet",alg="huber")
#Below plots the coefficient values for .1 quantile with a=.1
plot(r1,a=.1,tau=.1)
#Below code would provide plots for all possible values of a and tau
#plot(r1)
quants <- seq(.1,.9,.1)
r1 <- rq.pen(x,y,a=seq(0,1,.1),tau=quants,penalty="ENet",alg="huber")
#Below plots the coefficient values for .1 quantile with a=.1
plot(r1,a=.1,tau=.1,logLambda = TRUE)
#Below code would provide plots for all possible values of a and tau
#plot(r1)
plot(r1,logLambda=TRUE)
library(AmesHousing)
install.packages("AmesHousing")
library(AmesHousing)
ames_raw
library(AmesHousing)
ames <- make_ames()
x_g <- model.matrix(~ Lot_Shape+Garage_Type+Full_Bath+Fireplaces+Kitchen_Qual - 1,ames)
y_g <- log(ames$Sale_Price)
g <-  factor(apply(x, 1, paste, collapse = "."), labels = seq(ncol(x)))
head(rq.group.pen)
library(AmesHousing)
ames <- make_ames()
x_g <- model.matrix(~ Lot_Shape+Garage_Type+Full_Bath+Fireplaces+Kitchen_Qual - 1,ames)
y_g <- log(ames$Sale_Price)
g <-  c(rep(1,3),rep(2,6),3,4,rep(5,4))
r2 <- cv.rq.group.pen(x_g,y_g,groups=g)
r3 <- cv.rq.group.pen(x_g,y_g,groups=g,penalty="gSCAD",norm=1)
library(AmesHousing)
ames <- make_ames()
x_g <- model.matrix(~ Lot_Shape+Garage_Type+Full_Bath+Fireplaces+Kitchen_Qual - 1,ames)
y_g <- log(ames$Sale_Price)
g <-  c(rep(1,3),rep(2,6),3,4,rep(5,4))
r2 <- rq.group.pen.cv(x_g,y_g,groups=g)
r3 <- rq.group.pen.cv(x_g,y_g,groups=g,penalty="gSCAD",norm=1)
dim(x_g)
length(g)
head(x_g)
library(AmesHousing)
ames <- make_ames()
x_g <- model.matrix(~ Lot_Shape+Garage_Type+Full_Bath+Fireplaces+Kitchen_Qual - 1,ames)
y_g <- log(ames$Sale_Price)
g <-  c(rep(1,4),rep(2,6),3,4,rep(5,4))
r2 <- rq.group.pen.cv(x_g,y_g,groups=g)
r3 <- rq.group.pen.cv(x_g,y_g,groups=g,penalty="gSCAD",norm=1)
head(ames)
xtab(~ames$Lot_Shape)
xtabs(~ames$Lot_Shape)
library(AmesHousing)
ames <- make_ames()
x_g <- model.matrix(~ Lot_Shape+Garage_Type+Full_Bath+Fireplaces+Lot_Shape - 1,ames)
y_g <- log(ames$Sale_Price)
g <-  c(rep(1,4),rep(2,6),3,4,rep(5,4))
r2 <- rq.group.pen.cv(x_g,y_g,groups=g)
dim(x_g)
x_g
head(ames)
unique(ames$Lot_Config)
xtabs(~ames$Lot_Config)
library(AmesHousing)
ames <- make_ames()
x_g <- model.matrix(~ Lot_Shape+Garage_Type+Full_Bath+Fireplaces+Lot_Config - 1,ames)
y_g <- log(ames$Sale_Price)
g <-  c(rep(1,4),rep(2,6),3,4,rep(5,5))
r2 <- rq.group.pen.cv(x_g,y_g,groups=g)
dim(x_g)
length(g)
colnames(x_g)
g <-  c(rep(1,4),rep(2,6),3,4,rep(5,4))
r2 <- rq.group.pen.cv(x_g,y_g,groups=g)
r3 <- rq.group.pen.cv(x_g,y_g,groups=g,penalty="gSCAD",norm=1)
plot(r3)
r3
plot(r2)
plot(r2$fit)
plot(r2)
kernel
kernel
kernel
kernel
kernel
knitr::opts_chunk$set(dev = 'pdf')
library(Lock5withR)
hist(StudentSurvey$MathSAT)
hist(StudentSurvey$MathSAT, freq=FALSE, xlab="Score", main="Math SAT Score")
vals <- seq(400, 800, 1)
d_vals <- dnorm(vals, mean(StudentSurvey$MathSAT), sd(StudentSurvey$MathSAT))
lines(vals, d_vals, col="red")
mean(StudentSurvey$MathSAT)
sd(StudentSurvey$MathSAT)
z <- (StudentSurvey$MathSAT-600)/70
StudentSurvey$MathSAT[1:4]
z[1:4]
pierce <- StudentSurvey$Piercings[is.na(StudentSurvey$Piercings)==FALSE]
hist(pierce, main="Piercing Data for 361 Students", xlab="Piercing Number", freq=FALSE)
pierce_means_50 <- NULL
for(i in 1:10000){
s_mean <- mean(sample(pierce, 50, replace=FALSE))
pierce_means_50 <- c(pierce_means_50, s_mean)
}
hist(pierce_means_50, main="Histogram of 10,000 Sample Means from Piercing Data",
xlab="Sample Means with n=50", freq=FALSE)
hist(pierce, main="Piercing Data for 361 Students", xlab="Piercing Number", freq=FALSE)
hist(pierce_means_50, main="Histogram of 10,000 Sample Means from Piercing Data",
xlab="Sample Means with n=50", freq=FALSE)
z
xbar <- mean(StudentSurvey$MathSAT)
n <- length(StudentSurvey$MathSAT)
z <- (xbar-600)/ (70/sqrt(n))
z
pnorm(z)
quantile(pnorm(z))
qnorm(pnorm(z))
qnorm(pnorm(z),.5,.05)
knitr::opts_chunk$set(dev = 'pdf')
library(Lock5withR)
m1 <- lm(MathSAT~1,StudentSurvey)
coefficients(m1)
predict(m1)[1]
predict(m1,type="interval")
predict(m1,newdata=1,type="interval")
predict(m1)
m1
blah <- lm(MathSAT ~ Piercings, StudentSurvey)
blah
summary(blah)
with(StudentSurvey, plot(Piercings,MathSAT))
predict(blah)
predict(blah,type="interval")
newx <- data.frame(Piercings=c(1,3,5,6))
predict(blah,newx)
predict(blah,newx,type="interval")
predict(blah,newx, interval="predict")
predict(m1,interval="predict")
predict(m1,interval="predict")[1,]
predict(m1,interval="predict")[1,]
predict(m1,interval="predict",alpha=.68)[1,]
help(predict.lm)
predict(m1,interval="predict")[1,]
predict(m1,interval="predict",level=.68)[1,]
quantile(StudentSurvey$MathSAT, c(.025,.975))
predict(m1,interval="predict")[1,]
quantile(StudentSurvey$MathSAT, c(.84,.16))
predict(m1,interval="predict",level=.68)[1,]
mpierce <- lm(Piercings ~ 1, StudentSurvey)
quantile(StudentSurvey$Piercings, c(.025,.975))
mpierce <- lm(Piercings ~ 1, StudentSurvey)
quantile(StudentSurvey$Piercings, c(.025,.975),na.rm=TRUE)
predict(mpierce,interval="predict")[1,]
quantile(StudentSurvey$Piercings, c(.16,.84),na.rm=TRUE)
predict(mpierce,interval="predict",level=.68)[1,]
confint(m1)
confint(m1,level=.8)
predict(m1,interval="predict")[1,]
predict(m1,interval="predict",level=.68)[1,]
rm(list=ls(all=TRUE))
library(devtools)
devtools::unload("rqPen")
install_github("bssherwood/rqpen")
3
library(rqPen)
library(MASS)
rm(list=ls())
#-----------------------------------------------
tau <- 0.5 # the level of quantile
p <- 100  # the dimension of covariates
n <- 300  # sample size
beta <- matrix(0,1,p) # the coefficients
beta[1:5] <- 2
E <- matrix(rnorm(n, mean = 0, sd = 2),n,1) # error term
X <- matrix(rnorm(n*p, mean = 0, sd = 1.5),n,p) # covariates
Y <-  1+ X%*%t(beta) + E  # the response Y
#------------------------------------------------------------------------
cv_model <- cv.rq.pen(x=X,y=Y, lambda=NULL,weights=NULL,penalty="MCP",intercept=TRUE,
criteria="BIC", foldid=NULL,nlambda=100,eps=.0001,init.lambda=1,
penVars=NULL,alg = ifelse(ncol(X) < 50, "LP", "QICD"))
est_mcp <- coefficients(cv_model)
debug(cv.rq.pen)
cv_model <- cv.rq.pen(x=X,y=Y, lambda=NULL,weights=NULL,penalty="MCP",intercept=TRUE,
criteria="BIC", foldid=NULL,nlambda=100,eps=.0001,init.lambda=1,
penVars=NULL,alg = ifelse(ncol(X) < 50, "LP", "QICD"))
dim(XB)
length(y)
undebug(cv.rq.pen)
library(rqPen)
library(MASS)
rm(list=ls())
#-----------------------------------------------
tau <- 0.5 # the level of quantile
p <- 50  # the dimension of covariates
n <- 500  # sample size
beta <- matrix(0,1,p) # the coefficients
beta[1:5] <- 2
E <- matrix(rnorm(n, mean = 0, sd = 2),n,1) # error term
X <- matrix(rnorm(n*p, mean = 0, sd = 1.5),n,p) # covariates
Y <-  1+ X%*%t(beta) + E  # the response Y
#------------------------------------------------------------------------
cv_model <- cv.rq.pen(x=X,y=Y, lambda=NULL,weights=NULL,penalty="MCP",intercept=TRUE,
criteria="BIC", foldid=NULL,nlambda=100,eps=.0001,init.lambda=1,
penVars=NULL,alg = ifelse(ncol(X) < 50, "LP", "QICD"))
library(rqPen)
library(MASS)
rm(list=ls())
#-----------------------------------------------
tau <- 0.5 # the level of quantile
p <- 5  # the dimension of covariates
n <- 50  # sample size
beta <- matrix(0,1,p) # the coefficients
beta[1:5] <- 2
E <- matrix(rnorm(n, mean = 0, sd = 2),n,1) # error term
X <- matrix(rnorm(n*p, mean = 0, sd = 1.5),n,p) # covariates
Y <-  1+ X%*%t(beta) + E  # the response Y
#------------------------------------------------------------------------
cv_model <- cv.rq.pen(x=X,y=Y, lambda=NULL,weights=NULL,penalty="MCP",intercept=TRUE,
criteria="BIC", foldid=NULL,nlambda=100,eps=.0001,init.lambda=1,
penVars=NULL,alg = "QICD")
debug(cv.rq.pen)
cv_model <- cv.rq.pen(x=X,y=Y, lambda=NULL,weights=NULL,penalty="MCP",intercept=TRUE,
criteria="BIC", foldid=NULL,nlambda=100,eps=.0001,init.lambda=1,
penVars=NULL,alg = "QICD")
cv_model <- cv.rq.pen(x=X,y=Y, lambda=NULL,weights=NULL,penalty="MCP",intercept=TRUE,
criteria="BIC", foldid=NULL,nlambda=100,eps=.0001,init.lambda=1,
penVars=NULL,alg = "QICD")
class(y)
class(XB)
class(Y)
class(Y)
Y
Y <- as.numeric(Y)
class(Y)
cv_model <- cv.rq.pen(x=X,y=Y, lambda=NULL,weights=NULL,penalty="MCP",intercept=TRUE,
criteria="BIC", foldid=NULL,nlambda=100,eps=.0001,init.lambda=1,
penVars=NULL,alg = "QICD")
undebug(cv.rq.pen)
cv_model <- cv.rq.pen(x=X,y=Y, lambda=NULL,weights=NULL,penalty="MCP",intercept=TRUE,
criteria="BIC", foldid=NULL,nlambda=100,eps=.0001,init.lambda=1,
penVars=NULL,alg = "QICD")
class(Y)
class(Y)
class(X)
isnumeric
is.numeric
is.numeric(Y)
rm(list=ls(all=TRUE))
library(devtools)
devtools::unload("rqPen")
install_github("bssherwood/rqpen")
library(rqPen)
cv.rq.pen()
cv.rq.pen
tau <- 0.5 # the level of quantile
p <- 5  # the dimension of covariates
n <- 50  # sample size
beta <- matrix(0,1,p) # the coefficients
beta[1:5] <- 2
E <- matrix(rnorm(n, mean = 0, sd = 2),n,1) # error term
X <- matrix(rnorm(n*p, mean = 0, sd = 1.5),n,p) # covariates
Y <-  1+ X%*%t(beta) + E  # the response Y
#------------------------------------------------------------------------
cv_model <- cv.rq.pen(x=X,y=Y, lambda=NULL,weights=NULL,penalty="MCP",intercept=TRUE,
criteria="BIC", foldid=NULL,nlambda=100,eps=.0001,init.lambda=1,
penVars=NULL,alg = "QICD")
is.numeric(Y)
class(Y)
Y <- as.numeric(Y)
class(Y)
is.matrix(Y)
is.vector(Y)
rm(list=ls(all=TRUE))
library(devtools)
devtools::unload("rqPen")
install_github("bssherwood/rqpen")
library(rqPen)
cv.rq.pen()
cv.rq.pen
tau <- 0.5 # the level of quantile
p <- 5  # the dimension of covariates
n <- 50  # sample size
beta <- matrix(0,1,p) # the coefficients
beta[1:5] <- 2
E <- matrix(rnorm(n, mean = 0, sd = 2),n,1) # error term
X <- matrix(rnorm(n*p, mean = 0, sd = 1.5),n,p) # covariates
Y <-  1+ X%*%t(beta) + E  # the response Y
#------------------------------------------------------------------------
cv_model <- cv.rq.pen(x=X,y=Y, lambda=NULL,weights=NULL,penalty="MCP",intercept=TRUE,
criteria="BIC", foldid=NULL,nlambda=100,eps=.0001,init.lambda=1,
penVars=NULL,alg = "QICD")
library(roxygen2)
roxygen2::roxygenize()
setwd("C:/Users/b157s966/Dropbox/My PC (BUSN-1XWNDC2)/Documents/RPackage/rqpen")
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
roxygen2::roxygenize()
help(rq)
knitr:::write_bib()
